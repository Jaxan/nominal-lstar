{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleInstances         #-}
{-# LANGUAGE FunctionalDependencies    #-}
{-# LANGUAGE MultiParamTypeClasses     #-}

module Teacher where

import           NLambda

-- Explicit Prelude, as NLambda has quite some clashes
import           Data.Function           (fix)
import           Data.List               (zip, (!!), reverse)
import           Data.Maybe              (Maybe (..))
import           Prelude                 (Bool (..), Int, Read, Show, error,
                                          length, return, ($), (++), (-), (<),
                                          (==))
import qualified Prelude
import Control.Monad.Identity (Identity(..))

-- Used in the IO teacher
import           System.Console.Haskeline
import           System.IO.Unsafe        (unsafePerformIO)
import           Text.Read               (readMaybe)


-- Abstract teacher type (inside the NLambda library, ideally one would like
-- an external interface, with Bool as output instead of Formula for instance)
-- NOTE: Maybe neater when implemented as record?
class Teacher t i | t -> i where
    -- Given a sequence, check whether it is in the language
    -- Assumed to be equivariant
    membership :: t -> [i] -> Formula
    -- Given a hypothesis, returns Nothing when equivalence or a (equivariant)
    -- set of counter examples.
    equivalent :: (Show q, NominalType q) => t -> Automaton q i -> Maybe (Set [i])
    -- Returns the alphabet to the learner
    alphabet :: t -> Set i


-- Type for a teacher with an automaton as target
-- The state type is abstracted away
data TeacherWithTarget i = forall q . NominalType q => TeacherWithTarget (Automaton q i)

-- Implements the teacher
instance (NominalType i) => Teacher (TeacherWithTarget i) i where
    membership (TeacherWithTarget aut) input = accepts aut input
    equivalent (TeacherWithTarget aut) hypo = case solve isEq of
        Nothing -> error "should be solved"
        Just True -> Nothing
        Just False -> Just bisimRes
        where
            bisimRes = bisim aut hypo
            isEq = isEmpty bisimRes
    alphabet (TeacherWithTarget aut) = NLambda.alphabet aut

instance Conditional a => Conditional (Identity a) where
    cond f x y = return (cond f (runIdentity x) (runIdentity y))

-- Checks bisimulation of initial states
-- I am not sure whether it does the right thing for non-det automata
-- returns some counter examples if not bisimilar
-- returns empty set iff bisimilar
bisim :: (NominalType i, NominalType q1, NominalType q2) => Automaton q1 i -> Automaton q2 i -> Set [i]
bisim aut1 aut2 = runIdentity $ go empty (pairsWith addEmptyWord (initialStates aut1) (initialStates aut2))
    where
        go rel todo = do
            -- if elements are already in R, we can skip them
            let todo2 = filter (\(_, x, y) -> (x, y) `notMember` rel) todo
            -- split into correct pairs and wrong pairs
            let (cont, ces) = partition (\(_, x, y) -> (x `member` (finalStates aut1)) <==> (y `member` (finalStates aut2))) todo2
            let aa = NLambda.alphabet aut1
            -- the good pairs should make one step
            let dtodo = sum (pairsWith (\(w, x, y) a -> pairsWith (\x2 y2 -> (a:w, x2, y2)) (d aut1 a x) (d aut2 a y)) cont aa)
            -- if there are wrong pairs
            ite (isNotEmpty ces)
                -- then return counter examples
                (return $ map getRevWord ces)
                -- else continue with good pairs
                (ite (isEmpty dtodo)
                    (return empty)
                    (go (rel `union` map stripWord cont) (dtodo))
                )
        d aut a x = mapFilter (\(s, l, t) -> maybeIf (s `eq` x /\ l `eq` a) t) (delta aut)
        stripWord (_, x, y) = (x, y)
        getRevWord (w, _, _) = reverse w
        addEmptyWord x y = ([], x, y)


-- Will ask everything to someone reading the terminal
data TeacherWithIO = TeacherWithIO

-- For the moment only Atom as input type
-- Note that parsing is very unforgiving, one mistake, and there is no way back
-- Atoms are referenced by Ints. When the user provides a counter example, we
-- consider the whole orbit generated by it.
instance Teacher TeacherWithIO Atom where
    membership _ input = unsafePerformIO $ do
        let supp = leastSupport input
        Prelude.putStrLn "\n# Is the following word accepted?"
        Prelude.putStr "# "
        Prelude.print input
        Prelude.putStrLn "# You can answer with a formula (EQ, NEQ, AND, OR, T, F)"
        Prelude.putStrLn "# You may use the following atoms:"
        Prelude.putStr "# "
        Prelude.print $ zip supp [0..]
        answer <- runInputT defaultSettings loop
        return $ interpret supp answer
        where
            loop = do
                x <- getInputLine "> "
                case x of
                    Nothing -> error "Quit"
                    Just str -> do
                        case readMaybe str :: Maybe Form of
                            Nothing -> do
                                outputStrLn $ "Unable to parse " ++ str ++ " :: Form"
                                loop
                            Just f -> return f
    equivalent _ hypothesis = unsafePerformIO $ do
        Prelude.putStrLn "\n# Is the following automaton correct?"
        Prelude.putStr "# "
        Prelude.print hypothesis
        Prelude.putStrLn "# Nothing for Yes, Just [...] for a counter example"
        answer <- runInputT defaultSettings loop
        case answer of
            Nothing -> return Nothing
            Just input -> do
                -- create sequences of same length
                let n = length input
                let sequence = replicateAtoms n
                -- whenever two are identiacl in input, we will use eq, if not neq
                let op i j = if (input !! i) == (input !! j) then eq else neq
                -- copy the relations from input to sequence
                let rels s = and [op i j (s !! i) (s !! j) | i <- [0..n - 1], j <- [0..n - 1], i < j]
                let fseq = filter rels sequence
                return $ Just fseq
        where
            loop = do
                x <- getInputLine "> "
                case x of
                    Nothing -> error "Quit"
                    Just str -> do
                        case readMaybe str :: Maybe (Maybe [Prelude.String]) of
                            Nothing -> do
                                outputStrLn $ "Unable to parse " ++ str ++ " :: Maybe [String]"
                                loop
                            Just f -> return f
    alphabet _ = atoms

-- Data structure for reading formulas (with the derived Read instance)
data Form
    = EQ Int Int
    | NEQ Int Int
    | AND Form Form
    | OR Form Form
    | T
    | F
    deriving (Read)

interpret :: [Atom] -> Form -> Formula
interpret support (EQ i j) = eq (support !! i) (support !! j)
interpret support (NEQ i j) = neq (support !! i) (support !! j)
interpret support (AND f1 f2) = interpret support f1 /\ interpret support f2
interpret support (OR f1 f2) = interpret support f1 \/ interpret support f2
interpret _ T = true
interpret _ F = false


-- A teacher uses a target for the mebership queries, but you for equivalence
-- Useful as long as you don't have an equivalence check, For example for G-NFAs
data TeacherWithTargetAndIO i = forall q . NominalType q => TeacherWithTargetAndIO (Automaton q i)

instance Teacher (TeacherWithTargetAndIO Atom) Atom where
    membership (TeacherWithTargetAndIO aut) input = membership (TeacherWithTarget aut) input
    equivalent (TeacherWithTargetAndIO aut) aut2  = equivalent TeacherWithIO aut2
    alphabet (TeacherWithTargetAndIO aut)         = NLambda.alphabet aut
