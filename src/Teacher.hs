{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE FlexibleInstances         #-}

module Teacher
    ( module Teachers.Teacher
    , teacherWithTarget
    , teacherWithTargetNonDet
    , teacherWithIO
    , teacherWithTargetAndIO
    ) where

import Teachers.Teacher
import Teachers.Whitebox
import Teachers.Terminal

import NLambda hiding (alphabet)
import qualified NLambda (alphabet)

-- We provide three ways to construct teachers:
-- 1. Fully automatic
-- 2. Fully interactive (via IO)
-- 3. Automatic membership, but interactive equivalence tests
-- Furthermore we provide a teacher which counts and then passes the query
-- to a delegate.

-- 1. This is a fully automatic teacher, which has an internal automaton
-- Only works for DFAs for now, as those can be checked for equivalence
teacherWithTarget :: (NominalType i, NominalType q) => Automaton q i -> Teacher i
teacherWithTarget aut = Teacher
    { membership = foreachQuery $ accepts aut
    , equivalent = automaticEquivalent bisim aut
    , alphabet   = NLambda.alphabet aut
    }

-- 1b. This is a fully automatic teacher, which has an internal automaton
-- NFA have undecidable equivalence, n is a bound on deoth of bisimulation.
teacherWithTargetNonDet :: (Show i, Show q, NominalType i, NominalType q) => Int -> Automaton q i -> Teacher i
teacherWithTargetNonDet n aut = Teacher
    { membership = foreachQuery $ accepts aut
    , equivalent = automaticEquivalent (bisimNonDet n) aut
    , alphabet   = NLambda.alphabet aut
    }

-- 2. Will ask everything to someone reading the terminal
-- For the moment only Atom as input type
-- Note that parsing is very unforgiving, one mistake, and there is no way back
-- Atoms are referenced by Ints. When the user provides a counter example, we
-- consider the whole orbit generated by it.
teacherWithIO :: Teacher Atom
teacherWithIO = Teacher
    { membership = ioMembership
    , equivalent = ioEquivalent
    , alphabet   = atoms
    }

-- 3. A teacher uses a target for the mebership queries, but you for equivalence
-- Useful as long as you don't have an equivalence check
-- used for NFAs when there was no bounded bisimulation yet
teacherWithTargetAndIO :: NominalType q => Automaton q Atom -> Teacher Atom
teacherWithTargetAndIO aut = Teacher
    { membership = foreachQuery $ accepts aut
    , equivalent = ioEquivalent
    , alphabet   = atoms
    }

automaticEquivalent bisimlator aut hypo = case solve isEq of
        Nothing -> error "should be solved"
        Just True -> Nothing
        Just False -> Just bisimRes
        where
            bisimRes = bisimlator aut hypo
            isEq = isEmpty bisimRes
