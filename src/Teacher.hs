{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleInstances         #-}
{-# LANGUAGE FunctionalDependencies    #-}
{-# LANGUAGE MultiParamTypeClasses     #-}

module Teacher where

import           NLambda

-- Explicit Prelude, as NLambda has quite some clashes
import           Data.Function           (fix)
import           Data.List               (zip, (!!))
import           Data.Maybe              (Maybe (..))
import           Prelude                 (Bool (..), IO, Int, Read, Show, error,
                                          fmap, length, return, ($), (++), (-),
                                          (<), (==))
import qualified Prelude

-- Used in the IO teacher
import           System.Console.Readline
import           System.IO.Unsafe        (unsafePerformIO)
import           Text.Read               (readMaybe)


-- Abstract teacher type (inside the NLambda library, ideally one would like
-- an external interface, with Bool as output instead of Formula for instance)
-- NOTE: Maybe neater when implemented as record?
class Teacher t i | t -> i where
    -- Given a sequence, check whether it is in the language
    -- Assumed to be equivariant
    membership :: t -> [i] -> Formula
    -- Given a hypothesis, returns Nothing when equivalence or a (equivariant)
    -- set of counter examples.
    equivalent :: (Show q, NominalType q) => t -> Automaton q i -> Maybe (Set [i])
    -- Returns the alphabet to the learner
    alphabet :: t -> Set i


-- Type for a teacher with an automaton as target
-- The state type is abstracted away
data TeacherWithTarget i = forall q . NominalType q => TeacherWithTarget (Automaton q i)

-- Implements the teacher
instance (NominalType i) => Teacher (TeacherWithTarget i) i where
    membership (TeacherWithTarget aut) input = accepts aut input
    equivalent (TeacherWithTarget aut) hypo = case solve isEq of
        Nothing -> error "should be solved"
        Just True -> Nothing
        Just False -> Just ce
        where
            isEq = equivalentDA aut hypo
            lDiff = aut `differenceDA` hypo
            rDiff = hypo `differenceDA` aut
            symmDiff = lDiff `unionDA` rDiff
            ce = searchWord symmDiff
    alphabet (TeacherWithTarget aut) = NLambda.alphabet aut

-- Searching a word in the difference automaton
-- Will find all shortest ones
searchWord :: (NominalType i, NominalType q) => Automaton q i -> Set [i]
searchWord d = go (singleton [])
    where
        go aa = let candidates = filter (accepts d) aa in
            ite (isEmpty candidates)
                (go $ pairsWith (\as a -> a:as) aa (NLambda.alphabet d))
                candidates


-- Will ask everything to someone reading the terminal
data TeacherWithIO = TeacherWithIO

-- For the moment only Atom as input type
-- Note that parsing is very unforgiving, one mistake, and there is no way back
-- Atoms are referenced by Ints. When the user provides a counter example, we
-- consider the whole orbit generated by it.
instance Teacher TeacherWithIO Atom where
    membership _ input = unsafePerformIO $ do
        let supp = leastSupport input
        Prelude.putStrLn "\n# Is the following word accepted?"
        Prelude.putStr "# "
        Prelude.print input
        Prelude.putStrLn "# You can answer with a formula (EQ, NEQ, AND, OR, TRUE, FALSE)"
        Prelude.putStrLn "# You may use the following atoms:"
        Prelude.putStr "# "
        Prelude.print $ zip supp [0..]
        answer <- fix (\m -> do
                x <- readline "> "
                case x of
                    Nothing -> error "Quit"
                    Just str -> do
                        case readMaybe str :: Maybe Form of
                            Nothing -> do
                                Prelude.putStrLn $ "Unable to parse " ++ str ++ " :: Form"
                                m
                            Just f -> return f
            )
        return $ interpret supp answer
    equivalent _ hypothesis = unsafePerformIO $ do
        Prelude.putStrLn "\n# Is the following automaton correct?"
        Prelude.putStr "# "
        Prelude.print hypothesis
        Prelude.putStrLn "# Nothing for Yes, Just [...] for a counter example"
        answer <- fix (\m -> do
                x <- readline "> "
                case x of
                    Nothing -> error "Quit"
                    Just str -> do
                        case readMaybe str :: Maybe (Maybe [Prelude.String]) of
                            Nothing -> do
                                Prelude.putStrLn $ "Unable to parse " ++ str ++ " :: Maybe [String]"
                                m
                            Just f -> return f
            )
        case answer of
            Nothing -> return Nothing
            Just input -> do
                -- create sequences of same length
                let n = length input
                let sequence = replicateAtoms n
                -- whenever two are identiacl in input, we will use eq, if not neq
                let op i j = if (input !! i) == (input !! j) then eq else neq
                -- copy the relations from input to sequence
                let rels s = and [op i j (s !! i) (s !! j) | i <- [0..n - 1], j <- [0..n - 1], i < j]
                let fseq = filter rels sequence
                return $ Just fseq
    alphabet _ = atoms

-- Data structure for reading formulas (with the derived Read instance)
data Form
    = EQ Int Int
    | NEQ Int Int
    | AND Form Form
    | OR Form Form
    | TRUE
    | FALSE
    deriving (Read)

interpret :: [Atom] -> Form -> Formula
interpret support (EQ i j) = eq (support !! i) (support !! j)
interpret support (NEQ i j) = neq (support !! i) (support !! j)
interpret support (AND f1 f2) = interpret support f1 /\ interpret support f2
interpret support (OR f1 f2) = interpret support f1 \/ interpret support f1
interpret _ TRUE = true
interpret _ FALSE = false
